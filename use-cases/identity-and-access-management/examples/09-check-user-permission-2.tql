# Example 09:

# Filip is new, so he doesn't realise that he can't approve his own requests. When he tries to do so, the following
# query is triggered:

match
$u isa user, has email "filip.inaros@vaticle.com";
$po isa purchase-order, has reference "MCRN-02";
$o isa operation, has name "approve order";
$ac isa access ($po, $o);
true == has_permission($u, $ac);
false == violates_policies($u, $ac);

# This time, we get no results returned. This is because the dynamic segregation policy we defined has automatically
# flagged this permission as being invalid because Filip was the one who submitted this purchase order.
# The segregation policy functions encode the logic needed to determine whether a permission is valid or not.


# fun segregation_policies_violated($s: subject, $ac1: access) -> { segregation-policy }:
# match
#     $ac1 isa access (accessed-object: $o, valid-action: $a1);
#     {
#         $po isa static-segregation-policy (segregated-action: $a1, segregated-action: $a2);
#         $ac2 isa access (accessed-object: $o, valid-action: $a2);
#         true == has_permission($s, $ac2);
#     } or {
#         $po isa dynamic-segregation-policy (segregated-action: $a1, segregated-action: $a2) ;
#         $ac2 isa access (accessed-object: $o, valid-action: $a2);
#         $ah isa access-history (accessing-subject: $s, exercised-access: $ac2);
#     };
# return { $po };

# fun violates_policies($s: subject, $ac1: access) -> boolean:
# match 
#     let $po in segregation_policies_violated($s, $ac1);
# return check;
#
# A segregation policy violating blocks an access under one of the two conditions:
#   1. A subject simultaneously holds two permissions defined under a static segregation policy; or 
#   2. A subject attempts to perform - on a certain object - an action defined under a dynamic segregation policy,
#        having previously performed the other action defined in the same policy - on the same object.
# In this case Filip attempted to "approve" the Order MCRN-02 having previously "submitted" the same order.
# This means that Filip is still free to approve other orders, and other users are still free to approve this one.

#--------------------------------------------------
# Exercise 09:

# Edit this query to only list the names of users that are able to approve this purchase order for Filip.
# Keyword hints: select
# Type hints: full-name

#--------------------------------------------------
